## Git
***

1. Команды git:
	* создание ветки - ` git branch branch_name `
	* удаление ветки - ` git -d branch_name `
	* создание коммита - ` git commit -m "description" `
	* индексация изменений - ` git add . or file.html `
	* слияние ветки - ` git merge second_branch `
	* подключение внешнего репозитория - ` git remote add origin https://github.com... `
	* отправка данных в ВР - ` git push origin master `
	* получение данных из ВР - ` git fetch origin `

2. Отличие git от других SVC:
	* Распределенная модель
	* Сохраняет метаданные изменений, а не файлы
	* Полная история разработки доступная оффлайн
	* Быстрая работа
	* Легче выполнять определенные действия(команды)

3. Разница между merge и rebase:
	- rebase повторно применяет коммиты поверх другой базовой ветки
	- merge объединяет две или более историй разработки
	Merge сохраняет историю в первозданном виде, а rebase ее перезаписывает.

4. Основные стратегии ветвления:
	* GitHub Flow
		* в коде в мастер-ветке не допускаются ошибки, и он должен быть готов к развертыванию в любой момент;
		* чтобы начать разрабатывать новую функцию, необходимо создать feature-ветку в master-ветке и дать ей очевидное для всех имя. Когда работа будет готова, ее нужно смерджить в master-ветку через pull request;
		* после мерджа изменений их нужно сразу же развернуть на сервере.
	* GitFlow
	  	Два типа постоянных веток: master-ветка, чтобы понимать, как выглядит последняя актуальная версия, и development-ветка, где ведется разработка. От нее идут три вида временных веток:
		* Feature, для добавления новых возможностей. После завершения работы нужно создать pull request в development-ветку.
		* Release, для работы над новыми версиями. Важно добавить в название номер версии, это поможет не запутаться и отследить изменения.
		* Hotfix, для быстрого исправления багов.
	* Forking Workflow.
		Существует оригинальный репозиторий для мерджа всех изменений и его копия, в которой работает другой разработчик. Подход очень близок к идеологии open source, его цель — использовать все преимущества open-source-сообщества в рамках проекта. При этом большая часть рабочего процесса в части ветвления копирует GitFlow. Feature-ветки здесь будут мерджиться с локальными репозиториями разработчиков. Таким образом, разработка становится гибкой даже для очень больших команд с подрядчиками.
	* Правила Microsoft
		* не усложняйте вашу бранч-стратегию;
		* используйте feature-ветки для всех обновлений и исправления ошибок;
		* объединяйте feature-ветки в основные с помощью pull requests;
		* поддерживайте высокое качество и актуальность основной ветки.

## Docker
***

1. Отличие контейнеризации от виртуализации:
	Контейнер использует ядро хоста для обработки данных. Все контейнеры узла используют общее ядро. А при аппаратоной виртуализации эмулируется аппаратоное окружение и может быть запущен широкий спектр гостевых операционных систем.

2. Команды Docker:
	* сборка образа - ` docker build . `
	* старт контейнера - ` docker run `
	* остановка контейнера - ` docker stop `
	* удаление контейнера - ` docker rm `
	* удаление образа - ` docker rmi `
	* получение образа из репозитория - ` docker pull `
	* отправка образа в репозиторий - ` docker push `
	* запуск команды внутри контейнера - ` docker exec `

## Dockerfile
***

1. Корневой или же родительский образ - это исходный слой создаваемого образа. То есть это образ, на основе которого готовится наш образ.

2. Команды, которые создают новые слои:
	* FROM
	* RUN
	* COPY
	* ADD

3. Отличие entrypoint от cmd?
	* CMD - предоставляет значения по умолчанию для исполняемого контейнера.
	* ENTRYPOINT - помогает сконфигурировать контейнер, который можно запустить как исполняемый файл.

## Docker-compose
***

1. Команды Docker-compose:
	* создание контейнера - ` docker-compose up `
	* старт контейнера - ` docker-compose start `
	* удаление контейнера - ` docker-compose down / rm `
	* выполнения команды ` внутри контейнера - docker-compose exec `
	* удаление образа - ` docker-compose down `

2. Разделы docker-compose.yml:
	* services
	* client
	* version
	* volumes
	* networks

3. Минимальный docker-compose.yml, который будет работать:
	```
	version: "3"
	services:
		nginx:
			image: nginx
	```
## Linux
***

1. Отличия ОС Linux от других ос:
	* Свобода программного обеспечения (Open Source). Абсолютно любой разработчик может вносить свои изменения в работу системы и подогнать ее исключительно под свои нужды.
	* Также ОС linux отличается структурой файловой системы. Файловая система Linux начинается с корня, тоесть с основного каталога системного раздела, а уже там состоится подключение всех других дисков по необходимых подкаталогах.
	* Эта операционная система полностью безопасна и не боится никаких вирусов.

2. Ядро - это своего рода главная программа, являющаяся основной частью операционной системы. Оно выступает в роли посредника между устройствами компьютера и его программным обеспечением, абстрагируя от обычных программ и пользователей сложную, низкоуровневую работу с "железом" компьютера, предоставляя взамен простой, понятный и удобный в использовании интерфейс.

3. Загрузчик - это системная программа, выполняющая загрузку ОС в память.

4. Порядок загрузки Linux:
	1. Включение компьютера (BIOS + MBR)
		Базовая система ввода/вывода(BIOS) загружает начальную загрузочную запись(MBR)
	2. Загрузчик (GRUB)
		MBR -> Большой унифицированный загрузчик (GRUB)
	3. Ядро (Kernel)
		GRUB -> Kernel
	4. Запуск пользовательских служб (Init)
		Kernel -> /sbin/init
	5. Экранный менеджер рабочего стола (Runlevel)
		Программы уровней выполнения загружаются из /etc/rc.d/rc\*.d/

5. Устройство ядра:
	| Ядро | | 
	 --- | ---
	Интерфейс системных вызовов (SCI)
	Менеджер процессов (PM) | Виртуальная файловая система (VFS)
	Управление памятью (MM) | Сетевой стек
	Архитектурно-зависимая часть | Драйверы устройств (DD)

6. Порядок действий, для поиска логов неизвестной программы в файловой системе:

	Не понял вопрос, но скорее всего пойду гуглить где находятся логи обычно или логи этой программы. Если логи Linux то пойду искать дефолтный путь от корневой папки (/var/log), и скорее всего мне понадобяться права суперпользователя для того чтобы просмотреть их. Если же от другой программы, неизвестной мне, и в интернете информацию не получается найти где храняться её логи, или же в настройках программы тоже нет информации об этом, то постараюсь поискать их либо в папке с самой программой либо где-то ближе к корню в файлах которые связаны с системой поискать что-то связанное с названием этой программы. Ну или просто смотреть названия всех логов и искать сходство с названием программы.
